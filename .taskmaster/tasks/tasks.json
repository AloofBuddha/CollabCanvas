{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Set up project structure and dependencies",
        "description": "Initialize the React TypeScript project with necessary dependencies including Konva, Zustand, Firebase, TailwindCSS, and Vitest for testing.",
        "details": "Create a new React project using Vite or Create React App with TypeScript. Install dependencies: react-konva, zustand, firebase, tailwindcss, vitest. Configure TailwindCSS for styling. Set up project folders: components, stores, utils, tests. Ensure Firebase is configured with project ID, API key, etc., for Auth, Firestore, and Realtime DB.",
        "testStrategy": "Verify project builds successfully and all dependencies are installed without errors. Run a basic test to ensure Vitest is set up.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-16T15:31:54.695Z"
      },
      {
        "id": 2,
        "title": "Implement Firebase Auth integration",
        "description": "Set up Firebase Authentication for email/password sign-up and login, including saving user data to Firestore.",
        "details": "Initialize Firebase app with config. Create auth functions for signUp, login, logout using Firebase Auth SDK. On sign-up, save displayName and assign a random color to /users/{userId} in Firestore. Handle auth state changes to update user store.",
        "testStrategy": "Unit tests for signUp, login, logout functions using Vitest mocks for Firebase. Manual test: sign up, log in, check Firestore data.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-16T15:31:56.765Z"
      },
      {
        "id": 3,
        "title": "Create Auth page UI and routing",
        "description": "Build the authentication page with forms for sign-up and login, including validation and error handling.",
        "details": "Create AuthPage component with email, password, displayName fields. Use React Hook Form or native state for validation (email format, password length). Add buttons for Sign Up, Login. Implement routing to protect canvas route, redirecting unauthenticated users to auth page. Style with TailwindCSS for full-screen modal aesthetic.",
        "testStrategy": "Manual tests: fill forms, submit, check validation errors. Unit tests for form validation logic.",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-16T15:31:58.816Z"
      },
      {
        "id": 4,
        "title": "Set up Zustand stores for state management",
        "description": "Implement useUserStore, useCursorStore, and useShapeStore as per the PRD specifications.",
        "details": "Create Zustand stores with the provided interfaces. For useUserStore: manage userId, displayName, color, online, authStatus. For useCursorStore: localCursor and remoteCursors. For useShapeStore: shapes map with add, update, remove methods. Ensure stores are reactive and integrate with Firebase listeners.",
        "testStrategy": "Unit tests for store actions: addShape, updateShape, etc. Verify state updates correctly.",
        "priority": "medium",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-16T15:32:00.928Z"
      },
      {
        "id": 5,
        "title": "Implement canvas rendering with Konva",
        "description": "Set up the canvas component using React Konva for rendering shapes and handling interactions.",
        "details": "Create Canvas component with Stage and Layer. Set canvas size to 5000x5000px, enable panning with spacebar. Render rectangles from shapeStore. Add event handlers for mouse movements to update localCursor. Style with white background and light-gray grid.",
        "testStrategy": "Manual test: render empty canvas, pan around. Unit test: verify canvas dimensions and grid rendering.",
        "priority": "medium",
        "dependencies": [
          "4"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-16T15:32:02.976Z"
      },
      {
        "id": 6,
        "title": "Add local rectangle creation and movement",
        "description": "Implement creating and moving rectangles locally without sync yet.",
        "details": "Add toolbar component (bottom-center) with Select and Rectangle tools. On Rectangle tool, handle click+drag to create preview rectangle, commit on mouseup. For movement: select rectangle, drag to update position. Update shapeStore locally. Show border in user color during drag.",
        "testStrategy": "Manual tests: create rectangle, move it. Unit tests for shape creation logic.",
        "priority": "medium",
        "dependencies": [
          "5"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-16T15:32:04.990Z"
      },
      {
        "id": 7,
        "title": "Sync shapes with Firestore",
        "description": "Integrate shape synchronization with Firestore for real-time updates.",
        "details": "Listen to /canvas/state/shapes in Firestore, update shapeStore on changes. On local add/update/remove, write to Firestore. Handle conflicts by last-write-wins. Ensure shapes persist across sessions.",
        "testStrategy": "Manual multi-user test: create/move shapes, verify sync. Unit tests for Firestore listeners and writes.",
        "priority": "medium",
        "dependencies": [
          "6"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-16T15:32:07.140Z"
      },
      {
        "id": 8,
        "title": "Implement real-time cursors and presence",
        "description": "Add cursor tracking and user presence using Realtime DB.",
        "details": "Track local cursor position, send to /presence/{userId}/cursor. Listen to all presence, update remoteCursors with color and name (initials). Render cursors on canvas with labels. Handle online/offline, remove cursors on disconnect. Display avatars top-right.",
        "testStrategy": "Manual tests: move cursor, see remote cursors; disconnect user, verify removal. Unit tests for cursor updates.",
        "priority": "medium",
        "dependencies": [
          "7"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-16T15:32:09.270Z"
      },
      {
        "id": 9,
        "title": "Add persistence with localStorage",
        "description": "Implement canvas state restoration using localStorage.",
        "details": "On app load, load shapes from localStorage if Firestore is unavailable. Save shapes to localStorage on changes. Ensure seamless restore on reload.",
        "testStrategy": "Manual test: reload page, verify shapes persist. Unit test: localStorage read/write functions.",
        "priority": "low",
        "dependencies": [
          "8"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-16T15:32:11.265Z"
      },
      {
        "id": 10,
        "title": "Implement unit tests with Vitest",
        "description": "Write unit tests for auth, stores, and shape logic as per testing plan.",
        "details": "Use Vitest to test auth functions, store actions (addShape, updateShape), cursor throttling, and shape creation/movement logic. Mock Firebase for isolated tests.",
        "testStrategy": "Run Vitest suite, ensure all tests pass. Coverage for key functions.",
        "priority": "low",
        "dependencies": [
          "1",
          "2",
          "4",
          "6",
          "7",
          "8"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-16T15:32:13.329Z"
      },
      {
        "id": 11,
        "title": "Implement Multi-Select with Shift+Click",
        "description": "Enable users to select and manipulate multiple shapes simultaneously by supporting drag-to-select with a rectangle for selecting multiple shapes at once, and bulk operations such as deleting or moving selected shapes.",
        "status": "done",
        "dependencies": [
          4,
          5,
          6
        ],
        "priority": "high",
        "details": "Implemented multi-select feature with drag-to-select functionality. Updated the useShapeSelection hook to support multi-selection using a Set<string> for tracking selected shape IDs, including selectedShapeIds, isSelecting, and selectionBox state, while maintaining backward compatibility with selectedShapeId for single-selection. In the Canvas component, integrated drag-to-select: users can click and drag on empty canvas space to create a blue translucent selection rectangle; on mouse release, all shapes overlapping the rectangle (using AABB collision detection) are selected. Added visual feedback: selected shapes show selection borders, and the selection box renders with blue translucent fill and dashed stroke, scaling with canvas zoom. Supported multi-select operations: multi-drag (all selected shapes move together when dragging any of them), multi-delete (Delete or Backspace key removes all selected shapes), and ESC key to deselect all. Properly managed Firebase locks for all selected shapes during operations. UX constraints: DetailPane does not open for multi-select (only single selection); manipulation handles (resize/rotate) are disabled for multi-select, supporting only drag and delete. Files modified: src/hooks/useShapeSelection.ts (complete rewrite for multi-select with drag-to-select) and src/components/Canvas.tsx (integrated multi-select rendering, events, and multi-drag logic). Used Konva Rect for selection box rendering and extended delete callback to handle arrays of shape IDs.",
        "testStrategy": "Perform manual tests: create multiple shapes, drag a rectangle over shapes to select them en masse and verify selectedShapeIds updates; with multiple selected, press Delete or Backspace to remove them and confirm they disappear from canvas and Firestore; drag selected shapes to move them together and verify positions update in store and sync; press ESC to deselect all. Unit tests: mock useShapeSelection actions for multi-select operations, test AABB collision detection for drag-select, and verify bulk delete/move functions update the store correctly. Run Vitest suite for coverage on new selection logic, and conduct multi-user manual tests to ensure selections and operations sync properly without conflicts.",
        "subtasks": null
      },
      {
        "id": 12,
        "title": "Implement AI Canvas Agent for Natural Language Commands",
        "description": "Develop an AI-powered agent that interprets natural language commands to create, manipulate, and layout shapes on the canvas, supporting at least 8+ commands across creation, manipulation, layout, and complex operations like generating a login form. Integrate with the Grok API for command processing and ensure all operations sync to Firestore for real-time collaboration, targeting sub-3 second response times, atomic operations, and multi-user support to align with 25-point rubric requirements. The AI agent will be accessible via a toolbar button in the bottom toolbar, opening a text area for commands that executes on Enter or button click, with loading states, success/failure handling via toast notifications, and context awareness of all shapes, canvas dimensions, and user viewport.",
        "status": "in-progress",
        "dependencies": [
          2,
          4,
          5,
          6,
          7
        ],
        "priority": "high",
        "details": "Create a new AI Agent component or service that handles user input via a toolbar button in the bottom toolbar alongside other tools. Clicking the button opens a text area above the toolbar with an Execute button; commands execute on Enter key press or button click. While executing, the command remains visible and the Execute button shows a loading spinner; affected shapes are locked during execution. On success, clear the prompt and close the text area (optionally keep open); on failure, display a toast notification with error and keep text area open for retry. Use the Grok API to send natural language commands, providing full shape data, canvas dimensions, and user's current viewport (position/zoom) for spatial commands like 'move to center'. Receive structured responses (e.g., JSON objects specifying actions like createShape, updateShape, or layoutShapes), aiming for sub-3 second response times. Parse the API response to execute atomic actions on the shapeStore, such as creating rectangles, circles, or text elements based on commands like 'create a red rectangle at position 100,100', 'move selected shapes to the right', 'arrange shapes in a grid', or 'create a login form' which could generate multiple shapes (e.g., input fields, buttons). For complex operations, define a command parser that maps API outputs to store actions, ensuring compatibility with existing shape types from Task 6. Integrate error handling for invalid commands or API failures, using the existing toast notification system. Sync all shape changes to Firestore via the existing sync mechanism from Task 7, ensuring operations are persisted and real-time, with atomic operations to prevent conflicts in multi-user scenarios. Consider rate limiting API calls to avoid overuse, and store command history locally for undo/redo if needed. Update the UI to reflect AI-generated changes, and ensure the agent works with multi-user scenarios by syncing via Firestore. Use Zustand stores from Task 4 for state management, and render shapes on the Konva canvas from Task 5. For user authentication, leverage Task 2 to associate commands with the current user if required by the API. Align implementation with 25-point rubric requirements, including support for 8+ commands across categories, response time targets, atomicity, and multi-user support. Implementation phases: Start with infrastructure and one test command ('create a red circle at position 100, 200'), then add 8 basic commands one by one (creation: create [shape] [color] at [x,y]; manipulation: move [shape/selected], change [property], delete [shape]; layout: arrange in [grid/row/column]).",
        "testStrategy": "Conduct manual tests by entering various commands (e.g., 'create a blue circle', 'delete all rectangles', 'create a login form', 'align shapes vertically') and verify shapes appear, update, or layout correctly on the canvas within sub-3 seconds; check Firestore for synced changes in real-time. Test edge cases like invalid commands (e.g., 'fly to the moon') to ensure graceful error handling with toast notifications without crashing. Perform multi-user tests: have two users issue commands simultaneously and confirm shapes sync without conflicts, verifying atomic operations. Unit tests: Mock the Grok API responses and test command parsing logic, shape creation/manipulation functions, and integration with shapeStore actions using Vitest, including response time checks. Verify API call throttling and error handling. Integration tests: Simulate full workflows, such as creating a form via command and checking if all elements render and persist, ensuring alignment with rubric requirements. Implement and test each command individually before moving to the next, starting with the test command 'create a red circle at position 100, 200'.",
        "subtasks": [
          {
            "id": 1,
            "title": "Set Up Basic AI Agent Infrastructure",
            "description": "Create the foundational components for the AI Canvas Agent, including a toolbar button in the bottom toolbar, text area UI with Execute button, Grok API service integration, and a basic command parser to handle user inputs, starting with one test command.",
            "dependencies": [],
            "details": "Implement a toolbar button in the bottom toolbar alongside other tools; clicking opens a text area above the toolbar with an Execute button. Commands execute on Enter or button click, with loading spinner during execution and toast notifications for errors. Integrate a Grok API service to send commands (including full shape data, canvas dimensions, and viewport) and receive JSON responses. Develop a basic parser to interpret API outputs into actions like createShape or updateShape, ensuring sub-3 second response times and shape locking during execution. Start with infrastructure and one test command: 'create a red circle at position 100, 200'. Use Zustand stores for state management and ensure compatibility with existing shape types from Task 6.\n<info added on 2025-10-16T20:24:54.516Z>\n✅ Subtask 12.1 Infrastructure Complete!\n\nImplemented:\n- Installed LangChain, @langchain/openai, Zod, react-hot-toast\n- Created type definitions (src/types/aiAgent.ts) with Zod schemas\n- Built AI service (src/services/aiAgent.ts) using OpenAI gpt-4o-mini via LangChain\n- Implemented command parser (src/services/commandParser.ts) with shape generation\n- Created useAIAgent hook (src/hooks/useAIAgent.ts) for state management\n- Built UI components: AIAgentButton and AICommandInput with loading states\n- Integrated into Toolbar (sparkles icon with divider)\n- Integrated into CanvasPage with toast notifications\n- Build successful, no linter errors\n\nTest command ready: \"create a red circle at position 100, 200\"\n\nUser needs to add VITE_OPENAI_API_KEY to .env file before testing.\n</info added on 2025-10-16T20:24:54.516Z>\n<info added on 2025-10-16T21:36:31.516Z>\nEnhanced AI Agent with comprehensive shape property support!\n\nAdded full support for all shape properties:\n- Rotation for all shapes (circles, rectangles, lines, text)\n- Text properties: fontSize, fontFamily, textColor, align, verticalAlign\n- Stroke properties for borders\n- Text background: transparent by default, black text by default\n- Updated Zod schema with all optional properties\n- Comprehensive system prompt with 12+ examples covering all scenarios\n- Command parser handles all properties correctly\n\nExamples now supported:\n- \"create a red circle rotated 45 degrees\"\n- \"add text 'Hello' with font size 24 and Comic Sans\"\n- \"create centered text 'Title' with red text\"\n- \"add rotated text rotated 30 degrees with blue text\"\n- \"create thick red line\"\n- \"add blue rectangle with red border\"\n\nAll linting passes. Ready for testing with complex commands!\n</info added on 2025-10-16T21:36:31.516Z>\n<info added on 2025-10-16T21:45:52.673Z>\n✅ Fixed AI prompt UI positioning issues!\n\nResolved two critical UI problems:\n1. **Toolbar overlap**: AI prompt now uses `bottom-16` to properly clear the 64px toolbar\n2. **Detail pane responsiveness**: AI prompt now dynamically adjusts width when detail pane opens/closes\n   - Added `isDetailPaneOpen` state in CanvasPage\n   - Canvas component tracks detail pane visibility via useEffect\n   - AICommandInput receives `isDetailPaneOpen` prop and uses conditional `right-80` / `right-0` classes\n   - Smooth transitions with `transition-all duration-200`\n\nImplementation:\n- Canvas.tsx: Added `onDetailPaneVisibilityChange` callback prop\n- Canvas.tsx: useEffect tracks `selectedShapeId && selectedShapeIds.size === 1 && shapes[selectedShapeId]`\n- CanvasPage.tsx: Added `isDetailPaneOpen` state and passes to both Canvas and AICommandInput\n- AICommandInput.tsx: Conditional positioning based on detail pane state\n\nAll linting passes. Ready for testing!\n</info added on 2025-10-16T21:45:52.673Z>\n<info added on 2025-10-16T21:49:59.966Z>\nFixed toolbar overlap issue! Changed AI prompt positioning from bottom-16 (64px) to bottom-24 (96px) to properly clear the toolbar. Toolbar positioning analysis: Toolbar is at bottom-8 (32px from bottom) Toolbar has p-2 (8px padding top/bottom) Buttons are h-10 (40px height) Total clearance needed: ~88px Using bottom-24 (96px) provides safe clearance Now both issues are resolved: Toolbar overlap fixed - AI prompt clears toolbar with proper spacing Detail pane responsive - AI prompt adjusts width dynamically All linting passes!\n</info added on 2025-10-16T21:49:59.966Z>\n<info added on 2025-10-16T21:56:08.003Z>\n✅ Fixed multi-command JSON parsing error!\n\n**Problem**: AI was returning multiple commands as comma-separated objects `{...},{...}` which is invalid JSON\n\n**Solution**: \n1. Updated Zod schema to support both single commands AND arrays:\n   - `AICommandResponseSchema = z.union([CommandSchema, z.array(CommandSchema)])`\n2. Updated system prompt to instruct AI:\n   - Single shape: return `{\"action\":\"createShape\",\"shape\":{...}}`\n   - Multiple shapes: return `[{\"action\":\"createShape\",\"shape\":{...}},{\"action\":\"createShape\",\"shape\":{...}}]`\n3. Updated `useAIAgent` hook to handle both formats:\n   - `const commands = Array.isArray(response) ? response : [response]`\n   - `const allShapes = commands.flatMap(cmd => parseCommand(cmd, userId))`\n\nNow supports:\n- Single shape commands\n- Multiple shape commands in one prompt (e.g., \"create a square\")\n- Proper JSON array format validation\n\nAll linting passes!\n</info added on 2025-10-16T21:56:08.003Z>\n<info added on 2025-10-16T22:10:43.906Z>\nImproved AI error handling and spatial reasoning!\n\n1. Graceful Error Handling:\n- AI sometimes returns {\"action\":\"error\",\"message\":\"...\"} which breaks Zod validation\n- Added pre-validation check: if parsed.action === 'error', throw user-friendly error with the message\n- Added Zod error handling: convert verbose validation errors to \"AI response format was invalid. Please try rephrasing your command.\"\n- Users now see clean toast messages like \"Creating a dog out of lines is not supported\" instead of verbose Zod errors\n\n2. Better Spatial Reasoning:\n- Added smiley face example to system prompt showing proper coordinate alignment\n- Added explicit instruction: \"When creating complex compositions (faces, objects, etc.), carefully calculate positions so shapes align properly\"\n- Added fail-safe: \"You MUST always return valid shape commands. If you cannot fulfill a request, create the closest approximation you can using available shapes\"\n\nNow handles:\n- Error responses from AI gracefully\n- Complex multi-shape compositions with better alignment\n- Invalid requests with user-friendly messages\n\nAll linting passes!\n</info added on 2025-10-16T22:10:43.906Z>\n<info added on 2025-10-16T22:20:24.967Z>\n✅ Enhanced system prompt with strict shape type constraints!\n\nProblem: AI was trying to use unsupported shape types like triangle when user asked for complex shapes like \"create a house\"\n\nSolution: Updated system prompt with CRITICAL CONSTRAINTS section:\n- Explicitly lists ONLY 4 allowed shape types: \"circle\", \"rectangle\", \"text\", \"line\"\n- States AI CANNOT create triangles, polygons, stars, or any other types\n- Emphasizes AI MUST approximate complex shapes using ONLY these 4 types\n- Added \"create a house\" example showing how to approximate a house using rectangles and lines (body, roof lines, door, window)\n\nNew Prompt Section:\nCRITICAL CONSTRAINTS:\n- You can ONLY use these 4 shape types: \"circle\", \"rectangle\", \"text\", \"line\"\n- You CANNOT create any other shape types (no triangles, polygons, stars, etc.)\n- You MUST approximate complex shapes using ONLY these 4 types\n- ALWAYS return either a single command object OR a JSON array of command objects\n- NEVER return any other format\n\nNow the AI will know to approximate complex shapes within the allowed constraints!\n\nAll linting passes!\n</info added on 2025-10-16T22:20:24.967Z>\n<info added on 2025-10-16T22:25:47.727Z>\n✅ Improved positioning strategy and fixed house example!\n\nProblem 1: House alignment issues\n- Roof lines weren't connecting properly to the house body\n- Fixed the example coordinates:\n  - House body: 200x150 rectangle at (300, 350)\n  - Roof lines: Connect from corners (300, 350) and (500, 350) to peak at (400, 280)\n  - Door: 60x80 rectangle at (370, 420) - centered in house\n  - Window: 50x50 rectangle at (320, 380) - left side of house\n\nProblem 2: AI always placing shapes at center\n- Added POSITIONING STRATEGY section to system prompt:\n  - If user specifies position → use exact position\n  - If no position + existing shapes → place in empty space away from others\n  - If no position + no shapes → use varied positions (not always center)\n  - Consider canvas dimensions and viewport\n  - For multiple shapes in one command → distribute across canvas\n\nAdditional improvement:\n- Added note about line endpoints: \"For lines in compositions, ensure endpoints connect to the shapes they're meant to join\"\n\nNow AI should:\n- Create better-aligned complex compositions\n- Intelligently place shapes to avoid overlap\n- Use varied positions instead of always centering\n\nAll linting passes!\n</info added on 2025-10-16T22:25:47.727Z>",
            "status": "done",
            "testStrategy": "Manual test: Click toolbar button, open text area, enter test command 'create a red circle at position 100, 200', verify execution with loading state, shape creation on canvas, and sync to Firestore within 3 seconds. Test failure handling with invalid command showing toast. Unit test: Mock Grok API responses and check parser output for the test command."
          },
          {
            "id": 2,
            "title": "Implement Core Creation Commands",
            "description": "Add support for creation commands to generate shapes like rectangles, circles, and text elements based on natural language inputs, building on the test command.",
            "dependencies": [
              1
            ],
            "details": "Extend the command parser to handle creation commands such as 'create [shape] [color] at [x,y]', starting with the test command and adding more one by one. Map API responses to shapeStore actions for atomic creation, syncing changes to Firestore via existing mechanisms from Task 7. Ensure operations are user-specific using Task 2 auth, render on Konva canvas from Task 5, and provide full context to AI.",
            "status": "done",
            "testStrategy": "Manual test: Enter creation commands one by one, verify shapes appear on canvas and sync to Firestore within 3 seconds. Check for multi-user support by having another user see changes in real-time. Test each command individually before proceeding."
          },
          {
            "id": 3,
            "title": "Implement Core Manipulation Commands",
            "description": "Add support for manipulation commands to update or delete existing shapes, such as moving, resizing, or changing properties, one by one.",
            "dependencies": [
              1
            ],
            "details": "Enhance the parser for manipulation commands like 'move [shape/selected]', 'change [property]', 'delete [shape]'. Use useShapeSelection hook for multi-select support from Task 11. Execute atomic updates on shapeStore, ensuring real-time sync to Firestore with conflict resolution for multi-user scenarios. Provide AI with full shape context and viewport for spatial commands.",
            "status": "pending",
            "testStrategy": "Manual test: Select shapes, enter manipulation commands one by one, verify updates on canvas and Firestore. Test with multiple users to ensure atomic operations prevent conflicts. Implement and test each command individually."
          },
          {
            "id": 4,
            "title": "Implement Layout and Complex Operations",
            "description": "Support layout commands and complex operations like generating multi-shape components, such as arranging shapes in a grid or creating a login form, adding one by one.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Add parser logic for layout commands like 'arrange in [grid/row/column]' and complex ones like 'create a login form' that generate multiple shapes (e.g., inputs, buttons). Make commands context-aware by considering existing canvas state, full shape data, and viewport. Ensure atomic operations and sync to Firestore, targeting sub-3 second times.",
            "status": "pending",
            "testStrategy": "Manual test: Enter layout and complex commands one by one, verify shapes are created/manipulated correctly and synced. Test context-awareness by checking commands adapt to current selections. Implement and test each individually."
          },
          {
            "id": 5,
            "title": "Add Polish, Error Handling, and Multi-User Optimization",
            "description": "Integrate error handling, command history UI, performance optimizations, and ensure full multi-user support with atomic operations and conflict resolution.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Implement user-friendly error messages via existing toast notification system for invalid commands or API failures. Add a command history UI for undo/redo, stored locally. Optimize for sub-3 second responses with rate limiting on API calls. Enhance multi-user sync via Firestore, ensuring atomicity and resolving conflicts. Update UI to reflect changes smoothly, including shape locking during execution.",
            "status": "pending",
            "testStrategy": "Manual test: Trigger errors, verify toast messages; use history for undo/redo; test performance and multi-user collaboration. Unit test: Mock API failures and check error handling. Ensure all commands are tested individually before final polish."
          }
        ]
      },
      {
        "id": 13,
        "title": "Implement Comprehensive Testing and Performance Optimization",
        "description": "Conduct thorough testing for conflict resolution in shape synchronization (including simultaneous operations, rapid edits, and delete vs edit conflicts), persistence and reconnection handling (including refresh, disconnect/reconnect, and network simulation), and performance validation with 100+ shapes and 5+ concurrent users, including FPS monitoring and bottleneck optimization. Additionally, implement connection status UI and ensure comprehensive results documentation.",
        "status": "pending",
        "dependencies": [
          "2",
          "4",
          "5",
          "6",
          "7",
          "8",
          "9"
        ],
        "priority": "high",
        "details": "This task focuses on end-to-end testing and optimization of the collaborative canvas application. Begin by setting up a testing environment that simulates multi-user scenarios using multiple browser tabs or instances, authenticated via Firebase Auth (from Task 2). Implement conflict resolution testing by creating scenarios where multiple users edit the same shapes simultaneously, verifying that the last-write-wins strategy (from Task 7) resolves conflicts correctly without data loss; include testing for simultaneous operations, rapid edits, and delete vs edit conflicts. For persistence and reconnection, test localStorage fallback (Task 9) by disconnecting and reconnecting to Firestore, ensuring shapes restore seamlessly and sync upon reconnection; incorporate refresh scenarios, disconnect/reconnect, and network simulation. Develop performance tests with 100+ shapes: generate and render a large number of shapes (rectangles, circles, etc.) using the shape store (Task 4 and 6), and sync them via Firestore (Task 7). Simulate 5+ concurrent users by running parallel sessions, tracking real-time updates and presence (Task 8). Add FPS monitoring by integrating a library like Stats.js or custom code to measure frame rates during canvas rendering (Task 5), logging FPS drops during high-load operations like panning, zooming, or shape manipulations. Identify bottlenecks through profiling tools (e.g., Chrome DevTools Performance tab) and optimize: reduce unnecessary re-renders in React Konva, throttle Firestore writes, optimize shape data structures in Zustand stores, and implement lazy loading for large canvases. Consider edge cases like network latency, offline mode, and memory usage with many shapes. Ensure all optimizations maintain real-time collaboration integrity. Implement a connection status UI to display real-time connection state (e.g., online/offline indicators) for better user feedback during testing and usage. Ensure comprehensive documentation of test results, including metrics for conflict resolution accuracy, persistence reliability, reconnection success rates, FPS under load, sync latency, memory consumption, and before/after optimization improvements.",
        "testStrategy": "Set up automated scripts or manual procedures to run tests in a controlled environment. For conflict resolution: Use 2-3 browser instances logged in as different users; simultaneously edit overlapping shapes (e.g., move/resize the same rectangle), perform rapid edits, and simulate delete vs edit conflicts; verify that the final state matches the last edit via Firestore logs and visual inspection. For persistence/reconnection: Disconnect internet, make changes, reconnect, and confirm shapes persist via localStorage and sync back to Firestore without loss; include refresh scenarios, disconnect/reconnect, and network simulation using tools like Chrome DevTools Network Throttling. For performance: Create a script to generate 100+ shapes programmatically; run with 5+ concurrent users (simulate via multiple tabs or devices); monitor FPS using integrated monitoring (target 30+ FPS under load); use Chrome DevTools to profile CPU/memory usage, identifying and measuring improvements after optimizations (e.g., reduce render time by 20%). Conduct load testing with tools like Artillery or manual multi-tab setups to ensure stability. Document results comprehensively, including before/after metrics for FPS, sync latency, memory consumption, conflict resolution success rates, persistence/reconnection reliability, and any UI feedback from connection status indicators. Run tests on various devices/browsers to ensure cross-platform reliability.",
        "subtasks": null
      },
      {
        "id": 14,
        "title": "Implement Keyboard Shortcuts for Shape Manipulation",
        "description": "Add keyboard shortcuts for nudging selected shapes with arrow keys (1px or 10px with Shift), duplicating shapes with Cmd/Ctrl+D, selecting all shapes with Cmd/Ctrl+A, and deselecting with Escape. Update the README to document all available shortcuts.",
        "details": "This task involves enhancing the canvas interaction by adding global keyboard event listeners to handle the specified shortcuts. Use React's useEffect hook in the main Canvas component (from Task 5) to attach event listeners to the window for keydown events, ensuring they work regardless of focus. For arrow key nudging: Check if shapes are selected (using the selectedShapes array from Task 11), then update their positions by 1px (or 10px if Shift is held) in the direction of the arrow key, updating the useShapeStore accordingly and syncing to Firestore if applicable. Prevent default browser behavior for these keys to avoid page scrolling. For duplication (Cmd/Ctrl+D): Clone the selected shapes by creating new shape objects with incremented positions (e.g., offset by 10px), add them to the store, and select the new shapes. For select all (Cmd/Ctrl+A): Set all shape IDs to the selectedShapes array. For deselect (Escape): Clear the selectedShapes array. Ensure cross-platform compatibility by checking for 'metaKey' (Cmd on Mac) or 'ctrlKey' (Ctrl on Windows/Linux). Integrate with existing shape movement logic from Task 6 for consistency. Update the README.md file in the project root to include a new section listing all shortcuts, such as arrow keys for nudging, Cmd/Ctrl+D for duplicate, etc., with brief descriptions. Consider accessibility by ensuring shortcuts don't conflict with screen readers or other tools.",
        "testStrategy": "Perform manual tests in the application: Create multiple shapes on the canvas. Test arrow key nudging by selecting shapes and pressing arrow keys (verify 1px movement) and Shift+arrow (verify 10px movement), checking position updates in the store and visual rendering. Test duplication by selecting shapes, pressing Cmd/Ctrl+D, and confirming new shapes appear offset and are selected. Test select all with Cmd/Ctrl+A, ensuring all shapes are highlighted; test deselect with Escape, verifying no shapes are selected. Verify persistence by reloading the page after changes. Run unit tests for any new functions added to the stores, mocking keyboard events with Vitest. Check README for accurate documentation of shortcuts.",
        "status": "pending",
        "dependencies": [
          "4",
          "5",
          "6",
          "11"
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Add PNG Export Functionality",
        "description": "Implement PNG export feature for the canvas using Konva's toDataURL() method, adding an Export button to the toolbar and supporting configurable viewport options like width and height.",
        "details": "To add PNG export functionality, integrate Konva's toDataURL() method in the Canvas component from Task 5. First, update the toolbar component from Task 6 to include a new 'Export' button positioned alongside the existing Select and Rectangle tools. When the Export button is clicked, trigger a function that calls stage.toDataURL({ mimeType: 'image/png', width: configurableWidth, height: configurableHeight }) to generate a PNG data URL of the current canvas viewport. Support configurable viewport options by adding state variables (e.g., via useState) for export width and height, with default values matching the canvas size (5000x5000px from Task 5), and provide UI controls like input fields or dropdowns in a modal or expanded toolbar section for users to set custom dimensions before export. Ensure the export captures the entire visible area or a specified region, considering panning offset. Handle the data URL by creating a download link (e.g., using a temporary <a> element with download attribute) to save the PNG file locally. Consider performance for large canvases by limiting max export size or adding loading indicators. Update the shapeStore if needed to persist export settings, but keep it lightweight. Ensure compatibility with existing interactions like selection and movement from Task 6.",
        "testStrategy": "Perform manual tests by opening the application, creating and arranging shapes on the canvas, then clicking the Export button. Verify that a PNG file is downloaded with the correct filename (e.g., 'canvas-export.png'). Open the exported image in an image viewer to confirm it accurately represents the canvas content, including shapes, positions, and any grid or background from Task 5. Test configurable options by setting custom width/height (e.g., 1000x1000px) via UI controls and exporting, then checking the image dimensions match. Test edge cases like exporting an empty canvas, after panning, or with multi-selected shapes from Task 11 if available. Use browser developer tools to monitor for errors in console during export. For automated verification, consider adding a unit test in Vitest (from Task 10) to mock the toDataURL call and verify the download trigger.",
        "status": "pending",
        "dependencies": [
          "5",
          "6"
        ],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Implement Shape Opacity and Z-Index Layering System",
        "description": "Add support for opacity and z-index based layering to all shapes to enable proper rendering of AI-generated compositions with correct stacking order. This includes updating shape models, Konva rendering, UI controls, and AI command integration.",
        "details": "This task is divided into three phases. **Phase 1: Opacity Support** - Add an 'opacity' field (number, 0-1, default 1.0) to all shape types in the shapeStore (e.g., rectangles, circles, text). Update the Canvas component's Konva rendering to apply the opacity prop to each shape. For text shapes, ensure opacity applies to the entire group (text + background). In the DetailPane, add an opacity slider (0-100%) that updates the selected shape's opacity and syncs changes via Firebase. **Phase 2: Z-Index Layering** - Add a 'zIndex' field (number) to all shape types, with a default strategy based on creation timestamp (newer shapes get higher zIndex). Before rendering in the Canvas component, sort the shapes array by zIndex (higher values on top). Add four buttons in the DetailPane: 'Bring to Front' (set zIndex to max+1), 'Send to Back' (set to min-1), 'Bring Forward' (increment zIndex), 'Send Backward' (decrement zIndex). Ensure these changes sync via Firebase and handle multi-select scenarios by applying to all selected shapes. **Phase 3: AI Integration** - Extend the AI command schema to include optional 'opacity' and 'zIndex' properties. Update the system prompt for the AI agent with examples of layering commands (e.g., 'create a house with overlapping windows at different z-indexes'). Modify the commandParser in the AI agent to parse and apply these properties when creating or updating shapes. Ensure the AI can generate properly layered compositions, integrating with Task 12's AI agent functionality. Technical considerations: Use Konva's native opacity support; manage z-index via array sorting before render to avoid Konva's z-index limitations; ensure all changes are atomic and sync to Firestore for real-time collaboration; handle edge cases like negative zIndex or opacity out of bounds.",
        "testStrategy": "Conduct manual and unit tests across all phases. For Phase 1: Create shapes (rectangles, circles, text), adjust opacity via DetailPane slider, verify visual opacity in Konva render (e.g., 50% opacity shows semi-transparent); check Firebase sync by reloading and confirming opacity persists. For Phase 2: Create multiple overlapping shapes, use DetailPane buttons to change z-index order, verify stacking (e.g., 'Bring to Front' places shape on top); test with multi-select (from Task 11) to apply layering to groups; confirm sorting logic by inspecting shapes array order before render. For Phase 3: Use the AI agent (from Task 12) to issue commands like 'create a red square with 50% opacity and z-index 5', verify shape creation with correct properties; test complex commands like 'build a layered house' and check proper z-index stacking. Run unit tests for shapeStore updates (opacity/zIndex fields), Konva rendering props, and commandParser handling. Simulate multi-user scenarios: Have two users adjust opacity/z-index simultaneously, verify last-write-wins resolution and real-time sync. Performance check: With 50+ shapes, ensure rendering FPS remains smooth during layering operations.",
        "status": "pending",
        "dependencies": [
          2,
          4,
          5,
          6,
          12
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Opacity Support for Shapes",
            "description": "Add an 'opacity' field to all shape types in the shapeStore, update Konva rendering to apply opacity, and add UI controls in DetailPane for adjusting opacity with Firebase sync.",
            "dependencies": [],
            "details": "Add an 'opacity' field (number, 0-1, default 1.0) to all shape types in the shapeStore (e.g., rectangles, circles, text). Update the Canvas component's Konva rendering to apply the opacity prop to each shape. For text shapes, ensure opacity applies to the entire group (text + background). In the DetailPane, add an opacity slider (0-100%) that updates the selected shape's opacity and syncs changes via Firebase. Use Konva's native opacity support and ensure changes are atomic for real-time collaboration.",
            "status": "done",
            "testStrategy": "Create shapes (rectangles, circles, text), adjust opacity via DetailPane slider, verify visual opacity in Konva render (e.g., 50% opacity shows semi-transparent); check Firebase sync by reloading and confirming opacity persists."
          },
          {
            "id": 2,
            "title": "Implement Z-Index Layering for Shapes",
            "description": "Add a 'zIndex' field to all shape types, sort shapes by zIndex before rendering, and add UI buttons in DetailPane for layering controls with Firebase sync.",
            "dependencies": [
              1
            ],
            "details": "Add a 'zIndex' field (number) to all shape types, with a default strategy based on creation timestamp (newer shapes get higher zIndex). Before rendering in the Canvas component, sort the shapes array by zIndex (higher values on top). Add four buttons in the DetailPane: 'Bring to Front' (set zIndex to max+1), 'Send to Back' (set to min-1), 'Bring Forward' (increment zIndex), 'Send Backward' (decrement zIndex). Ensure these changes sync via Firebase and handle multi-select scenarios by applying to all selected shapes. Manage z-index via array sorting before render to avoid Konva's z-index limitations.",
            "status": "done",
            "testStrategy": "Create multiple shapes, use layering buttons in DetailPane, verify stacking order visually on canvas; check Firebase sync by reloading and confirming zIndex persists; test multi-select layering operations."
          },
          {
            "id": 3,
            "title": "Integrate Opacity and Z-Index with AI Commands",
            "description": "Extend the AI command schema to include optional 'opacity' and 'zIndex' properties, update the system prompt, and modify the commandParser to parse and apply these properties.",
            "dependencies": [
              2
            ],
            "details": "Extend the AI command schema to include optional 'opacity' and 'zIndex' properties. Update the system prompt for the AI agent with examples of layering commands (e.g., 'create a house with overlapping windows at different z-indexes'). Modify the commandParser in the AI agent to parse and apply these properties when creating or updating shapes. Ensure the AI can generate properly layered compositions, integrating with Task 12's AI agent functionality. Handle edge cases like negative zIndex or opacity out of bounds.",
            "status": "pending",
            "testStrategy": "Test AI commands that include opacity and zIndex, verify shapes are created with correct properties and layering; check integration with existing AI functionality from Task 12."
          }
        ]
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-10-16T15:34:00.087Z",
      "taskCount": 15,
      "completedCount": 10,
      "tags": [
        "master"
      ],
      "created": "2025-10-16T15:37:35.414Z",
      "description": "Tasks for master context",
      "updated": "2025-10-17T15:28:50.274Z"
    }
  }
}